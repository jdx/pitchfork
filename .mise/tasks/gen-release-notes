#!/usr/bin/env bash
#MISE description="Generate editorialized release notes with Claude Code"
#USAGE arg "<tag>" help="Git tag to generate notes for"
#USAGE arg "<output_dir>" help="Directory to write title and notes files"
#USAGE arg "[prev_tag]" help="Previous git tag"
set -euo pipefail

tag="${usage_tag}"
output_dir="${usage_output_dir}"
prev_tag="${usage_prev_tag:-}"

mkdir -p "$output_dir"

# If no prev_tag provided, find the previous tag
if [[ -z $prev_tag ]]; then
	# Use grep -F for literal matching (dots in semver are not regex wildcards)
	prev_tag=$(git tag --sort=-v:refname | grep -F -A1 "${tag}" | tail -1)
	if [[ $prev_tag == "$tag" ]]; then
		# No previous tag found, use first commit (head -1 handles multiple root commits)
		prev_tag=$(git rev-list --max-parents=0 HEAD | head -1)
	fi
fi

# Get conventional commits between tags
changelog=$(git log --pretty=format:"- %s (%h)" "${prev_tag}..${tag}" 2>/dev/null || git log --pretty=format:"- %s (%h)" "${tag}" 2>/dev/null || echo "")

if [[ -z $changelog ]]; then
	echo "Error: No commits found for release"
	exit 1
fi

output_file="$output_dir/raw.md"

# Build prompt safely using printf to avoid command substitution on backticks in changelog
prompt=$(
	printf '%s\n' "You are writing release notes for pitchfork version ${tag}."
	printf '\n'
	printf '%s\n' "Pitchfork is a daemon supervisor CLI for developers. It manages background processes with features like auto-start/stop, cron scheduling, retry logic, and HTTP ready checks."
	printf '\n'
	printf '%s\n' "Here are the commits in this release:"
	printf '%s\n' "$changelog"
	printf '\n'
	cat <<'INSTRUCTIONS'
Write user-friendly release notes:

1. Start with a single "# <pithy title>" heading - a short, catchy title summarizing this release (will become the GitHub release title). For smaller or less impactful releases, keep the title understated and modest.

TONE CALIBRATION:
- Match the tone and length to the actual significance of the changes
- If the release is mostly small bug fixes or minor tweaks, be upfront about that—a sentence or two of summary is fine, don't write multiple paragraphs inflating the importance
- Reserve enthusiastic, detailed write-ups for releases with genuinely significant features or changes
- It's okay to say "This is a smaller release focused on bug fixes" when that's the case

2. Follow with a summary proportional to the significance of the changes
3. Organize into ### sections (Highlights, Bug Fixes, etc.)
4. Explain WHY changes matter to users
5. Include PR links and documentation links (https://pitchfork.jdx.dev/)
6. Include contributor usernames (@username). Do not thank @jdx since that is who is writing these notes.
7. Skip internal changes
INSTRUCTIONS
	printf '\n%s\n' "Write your output to the file: ${output_file}"
	printf '%s\n' "Do not output anything else — just write to the file."
)

# Use Claude Code to generate the release notes
echo "Generating release notes with Claude..."
echo "Version: $tag"
echo "Previous version: ${prev_tag:-none}"
echo "Changelog length: ${#changelog} chars"

if ! printf '%s' "$prompt" | claude -p \
	--model claude-opus-4-6 \
	--permission-mode bypassPermissions \
	--allowedTools "Read,Grep,Glob,Write($output_file)"; then
	echo "Error: Claude CLI failed"
	exit 1
fi

# Validate the output file was created and is non-empty
if [[ ! -s $output_file ]]; then
	echo "Error: Claude did not write release notes to $output_file"
	exit 1
fi

echo "Raw output:"
cat "$output_file"

output=$(cat "$output_file")

# Extract title from "# ..." heading on first line and separate from body
title=""
body="$output"
if echo "$output" | head -1 | grep -q "^# "; then
	title=$(echo "$output" | head -1 | sed 's/^# //')
	body=$(echo "$output" | tail -n +2)
fi

# Validate we got non-empty output
if [[ -z $body ]]; then
	echo "Error: Empty body after parsing"
	exit 1
fi

# Write parsed results to output directory
echo "$title" >"$output_dir/title"
echo "$body" >"$output_dir/notes"
echo "Wrote title and notes to $output_dir"
